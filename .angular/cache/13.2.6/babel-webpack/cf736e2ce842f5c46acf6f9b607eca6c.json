{"ast":null,"code":"import { EventEmitter, SimpleChanges } from '@angular/core';\nimport { isDigit } from '../../../utils/timepicker.utils';\nimport { TimeUnit } from '../../../models/time-unit.enum';\nimport { TimeParserPipe } from '../../../pipes/time-parser.pipe';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../../pipes/time-parser.pipe\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"@angular/forms\";\nimport * as i4 from \"../../../pipes/time-localizer.pipe\";\n\nconst _c0 = function (a0) {\n  return {\n    \"ngx-timepicker-control--active\": a0\n  };\n};\n\nexport let NgxTimepickerTimeControlComponent = /*#__PURE__*/(() => {\n  class NgxTimepickerTimeControlComponent {\n    constructor(timeParser) {\n      this.timeParser = timeParser;\n      this.timeChanged = new EventEmitter();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.timeList && this.time != null) {\n        if (this.isSelectedTimeDisabled(this.time)) {\n          this.setAvailableTime();\n        }\n      }\n    }\n\n    changeTime(event) {\n      event.stopPropagation();\n      const char = String.fromCharCode(event.keyCode);\n      const time = concatTime(String(this.time), char);\n      this.changeTimeIfValid(time);\n    }\n\n    onKeydown(event) {\n      event.stopPropagation();\n\n      if (!isDigit(event)) {\n        event.preventDefault();\n      }\n\n      switch (event.key) {\n        case 'ArrowUp':\n          this.increase();\n          break;\n\n        case 'ArrowDown':\n          this.decrease();\n          break;\n      }\n\n      if (this.preventTyping && event.key !== 'Tab') {\n        event.preventDefault();\n      }\n    }\n\n    increase() {\n      if (!this.disabled) {\n        let nextTime = +this.time + 1;\n\n        if (nextTime > this.max) {\n          nextTime = this.min;\n        }\n\n        if (this.isSelectedTimeDisabled(nextTime)) {\n          nextTime = this.getAvailableTime(nextTime, this.getNextAvailableTime.bind(this));\n        }\n\n        if (nextTime !== this.time) {\n          this.timeChanged.emit(nextTime);\n        }\n      }\n    }\n\n    decrease() {\n      if (!this.disabled) {\n        let previousTime = +this.time - 1;\n\n        if (previousTime < this.min) {\n          previousTime = this.max;\n        }\n\n        if (this.isSelectedTimeDisabled(previousTime)) {\n          previousTime = this.getAvailableTime(previousTime, this.getPrevAvailableTime.bind(this));\n        }\n\n        if (previousTime !== this.time) {\n          this.timeChanged.emit(previousTime);\n        }\n      }\n    }\n\n    onFocus() {\n      this.isFocused = true;\n      this.previousTime = this.time;\n    }\n\n    onBlur() {\n      this.isFocused = false;\n\n      if (this.previousTime !== this.time) {\n        this.changeTimeIfValid(+this.time);\n      }\n    }\n\n    onModelChange(value) {\n      this.time = +this.timeParser.transform(value, this.timeUnit);\n    }\n\n    changeTimeIfValid(value) {\n      if (!isNaN(value)) {\n        this.time = value;\n\n        if (this.time > this.max) {\n          const timeString = String(value);\n          this.time = +timeString[timeString.length - 1];\n        }\n\n        if (this.time < this.min) {\n          this.time = this.min;\n        }\n\n        this.timeChanged.emit(this.time);\n      }\n    }\n\n    isSelectedTimeDisabled(time) {\n      return this.timeList.find(faceTime => faceTime.time === time).disabled;\n    }\n\n    getNextAvailableTime(index) {\n      const timeCollection = this.timeList;\n      const maxValue = timeCollection.length;\n\n      for (let i = index + 1; i < maxValue; i++) {\n        const time = timeCollection[i];\n\n        if (!time.disabled) {\n          return time.time;\n        }\n      }\n    }\n\n    getPrevAvailableTime(index) {\n      for (let i = index; i >= 0; i--) {\n        const time = this.timeList[i];\n\n        if (!time.disabled) {\n          return time.time;\n        }\n      }\n    }\n\n    getAvailableTime(currentTime, fn) {\n      const currentTimeIndex = this.timeList.findIndex(time => time.time === currentTime);\n      const availableTime = fn(currentTimeIndex);\n      return availableTime != null ? availableTime : this.time;\n    }\n\n    setAvailableTime() {\n      this.time = this.timeList.find(t => !t.disabled).time;\n      this.timeChanged.emit(this.time);\n    }\n\n  }\n\n  NgxTimepickerTimeControlComponent.ɵfac = function NgxTimepickerTimeControlComponent_Factory(t) {\n    return new (t || NgxTimepickerTimeControlComponent)(i0.ɵɵdirectiveInject(i1.TimeParserPipe));\n  };\n\n  NgxTimepickerTimeControlComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: NgxTimepickerTimeControlComponent,\n    selectors: [[\"ngx-timepicker-time-control\"]],\n    inputs: {\n      time: \"time\",\n      min: \"min\",\n      max: \"max\",\n      placeholder: \"placeholder\",\n      timeUnit: \"timeUnit\",\n      disabled: \"disabled\",\n      timeList: \"timeList\",\n      preventTyping: \"preventTyping\"\n    },\n    outputs: {\n      timeChanged: \"timeChanged\"\n    },\n    features: [i0.ɵɵProvidersFeature([TimeParserPipe]), i0.ɵɵNgOnChangesFeature],\n    decls: 9,\n    vars: 13,\n    consts: [[1, \"ngx-timepicker-control\", 3, \"ngClass\"], [\"maxlength\", \"2\", 1, \"ngx-timepicker-control__input\", 3, \"ngModel\", \"placeholder\", \"disabled\", \"ngModelChange\", \"keydown\", \"keypress\", \"focus\", \"blur\"], [1, \"ngx-timepicker-control__arrows\"], [\"role\", \"button\", 1, \"ngx-timepicker-control__arrow\", 3, \"click\"]],\n    template: function NgxTimepickerTimeControlComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"input\", 1);\n        i0.ɵɵlistener(\"ngModelChange\", function NgxTimepickerTimeControlComponent_Template_input_ngModelChange_1_listener($event) {\n          return ctx.onModelChange($event);\n        })(\"keydown\", function NgxTimepickerTimeControlComponent_Template_input_keydown_1_listener($event) {\n          return ctx.onKeydown($event);\n        })(\"keypress\", function NgxTimepickerTimeControlComponent_Template_input_keypress_1_listener($event) {\n          return ctx.changeTime($event);\n        })(\"focus\", function NgxTimepickerTimeControlComponent_Template_input_focus_1_listener() {\n          return ctx.onFocus();\n        })(\"blur\", function NgxTimepickerTimeControlComponent_Template_input_blur_1_listener() {\n          return ctx.onBlur();\n        });\n        i0.ɵɵpipe(2, \"timeLocalizer\");\n        i0.ɵɵpipe(3, \"timeParser\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"div\", 2)(5, \"span\", 3);\n        i0.ɵɵlistener(\"click\", function NgxTimepickerTimeControlComponent_Template_span_click_5_listener() {\n          return ctx.increase();\n        });\n        i0.ɵɵtext(6, \" \\u25B2 \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(7, \"span\", 3);\n        i0.ɵɵlistener(\"click\", function NgxTimepickerTimeControlComponent_Template_span_click_7_listener() {\n          return ctx.decrease();\n        });\n        i0.ɵɵtext(8, \" \\u25BC \");\n        i0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(11, _c0, ctx.isFocused));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngModel\", i0.ɵɵpipeBind3(2, 4, i0.ɵɵpipeBind2(3, 8, ctx.time, ctx.timeUnit), ctx.timeUnit, true))(\"placeholder\", ctx.placeholder)(\"disabled\", ctx.disabled);\n      }\n    },\n    directives: [i2.NgClass, i3.DefaultValueAccessor, i3.MaxLengthValidator, i3.NgControlStatus, i3.NgModel],\n    pipes: [i4.TimeLocalizerPipe, i1.TimeParserPipe],\n    styles: [\".ngx-timepicker-control[_ngcontent-%COMP%]{position:relative;display:flex;width:60px;height:30px;padding:0 5px;box-sizing:border-box}.ngx-timepicker-control--active[_ngcontent-%COMP%]:after{content:\\\"\\\";position:absolute;bottom:-2px;left:0;width:100%;height:1px;background-color:#00bfff}.ngx-timepicker-control__input[_ngcontent-%COMP%]{width:100%;height:100%;padding:0 5px 0 0;border:0;font-size:1rem;color:inherit;outline:none;text-align:center}.ngx-timepicker-control__input[_ngcontent-%COMP%]:disabled{background-color:transparent}.ngx-timepicker-control__arrows[_ngcontent-%COMP%]{position:absolute;right:2px;top:0;display:flex;flex-direction:column}.ngx-timepicker-control__arrow[_ngcontent-%COMP%]{font-size:11px;color:#0006;cursor:pointer;transition:color .2s;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ngx-timepicker-control__arrow[_ngcontent-%COMP%]:hover{color:#000000e6}\"],\n    changeDetection: 0\n  });\n  return NgxTimepickerTimeControlComponent;\n})();\n\nfunction concatTime(currentTime, nextTime) {\n  const isNumber = /\\d/.test(nextTime);\n\n  if (isNumber) {\n    const time = currentTime + nextTime;\n    return +time;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}